[{"id":0,"href":"/docs/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/gmp/","title":"Gmp","section":"go语言基础","content":"G的大小: 2-4k\n线程的大小 M?\n1、我们通过 go func () 来创建一个 goroutine；\n2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；\n3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；\n4、一个 M 调度 G 执行的过程是一个循环机制；\n5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；\n6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中\n参考链接: https://learnku.com/articles/41728\n进程和线程:http://staff.ustc.edu.cn/~huangwc/osppt/2.pdf\n视频理解:https://www.bilibili.com/video/BV1hv411x7we?p=16\n"},{"id":1,"href":"/docs/java%E5%9F%BA%E7%A1%80/jvm/","title":"Jvm","section":"java基础","content":"TODO\n"},{"id":2,"href":"/docs/java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"线程池","section":"java基础","content":"TODO\n"},{"id":3,"href":"/docs/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/","title":"集合","section":"java基础","content":"TODO\n"},{"id":4,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhosue/sql-join/","title":"SQL Join","section":"Clickhosue","content":"clickhouse\n常用操作\njoin # 所有的join 操作基本范式都是\n​\ttable1 join table2 on table.xxx=table2.xxx\n​\tjoin table3 on table1.xxx=table3.xxx\n​\tjoin table4 on table2.xxx=table4.xxx\n不允许先查询 再进行join,错误查询示例\nselect * from table_a where age=12 (inner) join table_b on table_a.id =table_b.id left joni table_c on table a.id=table_c.id where table_a.name=\u0026#39;xxxx\u0026#34; (innser)join操作 ​\t内连接,去两个表on 交集\nselect * from table_a (inner) join table_b on table_a.id =table_b.id where table_a.name=\u0026#39;\u0026#39;xxxx\u0026#34; ​\nLeft join\n左边为空时,会导致不会查到任何数据\n左连接,取左表所有\nselect * from table_a left join table_b on table_a.id =table_b.id where table_a.name=\u0026#39;\u0026#39;xxxx\u0026#34; right join\n右表所有,加on条件左表\nselect * from table_a right join table_b on table_a.id =table_b.id where table_a.name=\u0026#39;\u0026#39;xxxx\u0026#34; full join\nself join\ncross join\nunion all /union distinct # 基本语法\nSELECT column1, column2 ... FROM table1, table2 [WHERE condition1] UNION / UNION ALL SELECT column1, column2 ... FROM table1, table2 [WHERE condition2] union distinct会对数据进行去重,(mysql中union 本身就具有去重逻辑) union all 直接将结果数据进行连接 "},{"id":5,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/","title":"数据分片","section":"elasticsearch","content":"TODO\n"},{"id":6,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E8%B0%83%E4%BC%98/","title":"调优","section":"elasticsearch","content":"TODO\n"},{"id":7,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mvcc%E6%A8%A1%E5%9E%8B/","title":"Mvcc模型","section":"mysql","content":"TODO\n"},{"id":8,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1/","title":"事务","section":"mysql","content":"TODO\n"},{"id":9,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E6%9E%B6%E6%9E%84/","title":"架构","section":"redis","content":" redis 架构 # 持久化方式 # rdb: fork进程\naof: 一个线程,\n一致性hash: # 一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中 K 是关键字的数量，n 是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。\n多级缓存: # 缓存更新、缓存一致性问题\nkey\u0026mdash;key\u0026mdash;\u0026gt;value形式 还是key-value形式\n"},{"id":10,"href":"/docs/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E4%BF%A1%E6%9E%B6%E6%9E%84/","title":"微信架构","section":"架构","content":"微信架构\n"},{"id":11,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"TODO\n"},{"id":12,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","title":"回溯","section":"算法","content":"TODO\n"},{"id":13,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"算法","content":"贪心算法定义\n"},{"id":14,"href":"/menu/","title":"Index","section":"Introduction","content":" headless: true # "}]