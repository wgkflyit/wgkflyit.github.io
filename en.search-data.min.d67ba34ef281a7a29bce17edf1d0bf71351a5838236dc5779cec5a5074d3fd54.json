[{"id":0,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhosue/","title":"clickhosue","section":"数据库","content":"clickhouse基础功能介绍\n"},{"id":1,"href":"/docs/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/gmp%E6%A8%A1%E5%9E%8B/","title":"Gmp模型","section":"go语言基础","content":"G的大小: 2-4k\n线程的大小 M?\n1、我们通过 go func () 来创建一个 goroutine；\n2、有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；\n3、G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；\n4、一个 M 调度 G 执行的过程是一个循环机制；\n5、当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；\n6、当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中\n参考链接: https://learnku.com/articles/41728\n进程和线程:http://staff.ustc.edu.cn/~huangwc/osppt/2.pdf\n视频理解:https://www.bilibili.com/video/BV1hv411x7we?p=16\n"},{"id":2,"href":"/docs/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/","title":"反射","section":"go语言基础","content":" 1 反射使用 # 1.1 反射获取数据类型 # 通过relfect.TypeOf() 获取对应的类型,这个方法可以返回类型元数据信息,\nName方法返回类型对应的名字,如果是slice类型或者是指针类型,返回为空字符串 Kind方法对应的数据类型,int、string、struct、func,枚举值reflect.Kind类型 Size: 数据占用内存大小,单位字节 \u0026hellip; type Type interface { ... Name() string // 返回类型对应的名字 PkgPath() string // 类型所在路径 Kind() Kind // 类型元数据的所属类型,int32、float32、string、slice、map、struct、ptr... Elem() Type // 数组、切片、chan、map、指针类型存储的数据信息,其他类型会panic Field(i int) StructField // 返回sturct的某个字段元数据信息 ... } type Foo struct { Name string `tag1:\u0026#34;First Tag\u0026#34; tag2:\u0026#34;Second Tag\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { testCase := []interface{}{ 1, \u0026#34;1\u0026#34;, []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;}, map[int]int{1: 1, 2: 2}, Foo{ Name: \u0026#34;foo\u0026#34;, Age: 12, }, ioutil.ReadAll, \u0026amp;Foo{}, } for _, v := range testCase { callReflect(v) } } func callReflect(i interface{}) { of := reflect.TypeOf(i) if of.Kind() != reflect.Struct { fmt.Println(\u0026#34;name: \u0026#34;, of.Name(), \u0026#34;kind:\u0026#34;, of.Kind(), \u0026#34;size:\u0026#34;, of.Size()) return } fmt.Println(\u0026#34;name: \u0026#34;, of.Name(), \u0026#34;kind:\u0026#34;, of.Kind(), \u0026#34;size:\u0026#34;, \u0026#34;tag:\u0026#34;, of.Size(), of.Field(0).Tag) } 输出: name: int kind: int size: 8 name: string kind: string size: 16 name: kind: slice size: 24 name: kind: map size: 8 name: Foo kind: struct size: tag0: 24 tag1:\u0026#34;First Tag\u0026#34; tag2:\u0026#34;Second Tag\u0026#34; name: kind: func size: 8 name: kind: ptr size: 8 1.2 反射获取对应的值 # func main() { testCase := []interface{}{1, \u0026#34;1\u0026#34;, []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;}, map[int]int{1: 1, 2: 2}, Foo{Name: \u0026#34;foo\u0026#34;, Age: 12}, ioutil.ReadAll, \u0026amp;Foo{}} for _, v := range testCase { callReflect(v) } } func callReflect(i interface{}) { of := reflect.ValueOf(i) // reflect.ValueOf获取对应的数据值,先判断数据的Kind,然后在进行取值,否则会panic kind := of.Kind() switch kind { case reflect.Int: fmt.Println(of.Int()) case reflect.String: fmt.Println(of.String()) case reflect.Slice: for i := 0; i \u0026lt; of.Len(); i++ { fmt.Print(\u0026#34;slice :\u0026#34;, of.Index(i).String(), \u0026#34;\\t\u0026#34;) } fmt.Println() case reflect.Map: for _, v := range of.MapKeys() { fmt.Print(\u0026#34;map,key:\u0026#34;, v.Int(), \u0026#34;value:\u0026#34;, of.MapIndex(v).Int(), \u0026#34;\\t\u0026#34;) } fmt.Println() case reflect.Struct: fmt.Printf(\u0026#34;struct ,Name %s,age:%d\\n\u0026#34;, of.Field(0).String(), of.Field(1).Int()) } } 输出: 1 1 slice :1 slice :2 map,key:1value:1 map,key:2value:2 struct ,Name foo,age:12 1.3 反射修改值 # 通过reflect.ValueOf() 中传递指针可以对通过反射修改对应的数据,首先调用Elem方法,然后调用set方法进行修改,reflect的中的各种方法大多数误操作都会导致程序panic,所以在进行操作时\n私有变量的值不能进行修改,可以通过unsafe.Pointer进行修改\ntype Foo struct { Name string `tag1:\u0026#34;First Tag\u0026#34; tag2:\u0026#34;Second Tag\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func main() { f := Foo{Name: \u0026#34;foo\u0026#34;, Age: 12} callReflect(\u0026amp;f) fmt.Printf(\u0026#34;reflct value:%v\u0026#34;, f) } func callReflect(i interface{}) { if reflect.TypeOf(i).Kind() != reflect.Ptr { // 检测是否为指针,非指针拒绝修改 panic(\u0026#34;not ptr,cannot modify\u0026#34;) } of := reflect.ValueOf(i).Elem() // Elem 取地址实际指向的值 if of.Kind() == reflect.Struct \u0026amp;\u0026amp; of.Type().Name() == \u0026#34;Foo\u0026#34; { // 判断类型 if f := of.Field(1); f.CanSet() { //判断是否可以修改 f.SetInt(100) // 进行修改 } if f := of.Field(0); f.CanSet() { f.SetString(\u0026#34;reflect\u0026#34;) } return } 输出: reflct value:{reflect 100} 1.4 反射make # 可以通过反射创建数据,输入参数relcet.Type类型,输出为reflect.Value类型\nslice通过reflect.MakeSlice 创建,reflect.Append添加对应的元素 map通过内置的reflect.MakeMap创建 function通过reflect.MakeFunc创建 chan创建通过reflect.MakeChan 创建一个新的struct 通过reflect.StructOf函数创建,这种方式比较奇怪,应为新定义的struct 没有对应的名字,如果需要修改对应的struct 实例值,需要通过反射就行修改 2 反射优缺点 # 反射的优点\n通用性，可对类库和框架代码做极大的简化设计 灵活性，运行期动态获取数据的类型 反射的缺点:\n同样因为反射的概念和语法都比较抽象，滥用反射会使得代码难以被其他人读懂无法在编译时检查错误。 作为一种强类型的语言，go 的编译器会在编译阶段检查出类型错误，但是 interface 定义的类型是不明确的，代码在运行时存在 panic 的风险 降低了代码运行的效率，反射变量的类型需要额外的开销, 参考第4节 3 原理走读 # 3.1 类型元数据 # 类型名称、类型大小、对齐边界、是否自定义等，是每个类型元数据都要记录的信息，所以被放到了runtime.type中，作为每个类型元数据的header\nreflect.TypeOf 返回的type接口,对应*reflect.rtype类型, 和runtime._type完全一致\n![image-20220825110648993](/Users/wuguangkuo/Library/Application Support/typora-user-images/image-20220825110648993.png)\n_type 结构:\ntype _type struct { size uintptr // 类型大小 ptrdata uintptr // size of memory prefix holding all pointers hash uint32 tflag tflag align uint8 // 对齐边界 fieldAlign uint8 kind uint8 // 类型的种类 // function for comparing objects of this type // (ptr to object A, ptr to object B) -\u0026gt; ==? equal func(unsafe.Pointer, unsafe.Pointer) bool // gcdata stores the GC type data for the garbage collector. // If the KindGCProg bit is set in kind, gcdata is a GC program. // Otherwise it is a ptrmask bitmap. See mbitmap.go for details. gcdata *byte str nameOff // 类型名称字符串 ptrToThis typeOff } slice type:\ntype slicetype struct { typ _type // slice 类型 elem *_type // slice里的元数据类型 } map type:\ntype maptype struct { typ _type key *_type // key类型 elem *_type // value类型 bucket *_type // internal type representing a hash bucket // function for hashing keys (ptr to key, seed) -\u0026gt; hash hasher func(unsafe.Pointer, uintptr) uintptr keysize uint8 // size of key slot elemsize uint8 // size of elem slot bucketsize uint16 // size of bucket flags uint32 } stuct type:\ntype structtype struct { typ _type // 类型 pkgPath name // 包路径 fields []structfield // 字段 } type structfield struct { name name typ *_type offsetAnon uintptr } interface type:\ntype interfacetype struct { typ _type pkgpath name mhdr []imethod } 3.2 接口 # 接口类型的数据在运行中将会转变成以下两种类型\n3.2.1 空接口 # runtime.eface\ntype eface struct { _type *_type //动态类型 data unsafe.Pointer // 接口动态值 } 3.2.2 非空接口 # runtime.iface\n// iface 结构 type iface struct { tab *itab // itab结构体 data unsafe.Pointer //动态值 } // itab 结构体 type itab struct { inter *interfacetype //接口类型,定义接口实现的方法 _type *_type // 动态类型 hash uint32 // copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr // 动态类型实现的接口方法拷贝,系统会维持一份itab缓存,fun[0]==0 表示未实现对应的接口, } 类型别名与类型重定义\ntype rune=int32 同一种类型元数据\ntype type2 []slice 不同的类型元数据\ntype any = interface{} // go version1.18\n3.3 类型断言 # int、string、 slice、map 、空接口、非空接口\n空接口.(具体类型)\n![image-20220825112856067](/Users/wuguangkuo/Library/Application Support/typora-user-images/image-20220825112856067.png)\n只需要根据空接口的type 和被断言类型进行一次比较即可\n非空接口.(具体类型)\n![image-20220825113126766](/Users/wuguangkuo/Library/Application Support/typora-user-images/image-20220825113126766.png)\n非空接口运行时结构为itab,和data类型,需要判断接口的动态类型*os.File是否实现了io.ReadWriter接口类型,只需要遍历动态类型实现的方法,如果对应的方法实现了io.ReadWriter接口,则类型断言成功.\n接口类型和对应的动态类型确定下来,对应的itab接口就不会在进行变更,所以go内部会维持一个itab缓存,用于加快比较操作,用接口的hash^动态类型的hash,如果在itab缓存中则代表动态类型实现了接口\ntype itabTableType struct { size uintptr // length of entries array. Always a power of 2. count uintptr // current number of filled entries. entries [itabInitSize]*itab // really [size] large } func (t *itabTableType) find(inter *interfacetype, typ *_type) *itab { .... } 空接口.(非空接口)\n![image-20220820212352618](/Users/wuguangkuo/Library/Application Support/typora-user-images/image-20220820212352618.png)\n比较空接口的动态类型是否实现非空接口的方法 非空接口和空接口的动态类型是否在itab缓存中接口 非空接口.(非空接口)\n![image-20220820213907033](/Users/wuguangkuo/Library/Application Support/typora-user-images/image-20220820213907033.png)\n比较动态类型是否实现非空接口的方法 被断言非空接口和动态类型是否在itab缓存中接口 3.4 接口与反射 # 反射可以将“接口类型变量”转换为“反射类型对象”\n反射可以将“反射类型对象”转换为“接口类型变量”\n如果要修改“反射类型对象”，其值必须是“可写的”（settable） https://go.dev/blog/laws-of-reflection\nfunc main() { testInt := 1 of := reflect.ValueOf(testInt) // 接口类型值转换为反射类型的值, law-1 reflectInt := of.Interface() // 反射类型的值转换为接口类型的值 law-2 //of.SetInt(19) //panic law-3 reflect.ValueOf(\u0026amp;testInt).Elem().SetInt(12) fmt.Println(reflectInt, testInt) } ![image-20220820112359414](/Users/wuguangkuo/Library/Application Support/typora-user-images/image-20220820112359414.png)\n​\treflect中的rtype结构和runtime._type接口保持一致,runtime包中的内容不允许访问,所以才有了reflect包\n4 反射性能 # type Foo struct { Name string `tag1:\u0026#34;First Tag\u0026#34; json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } func BenchmarkReflectUpdate(b *testing.B) { f := Foo{ Name: \u0026#34;origin\u0026#34;, Age: 1, } for i := 0; i \u0026lt; b.N; i++ { //ReflectUpdate(\u0026amp;f) f.Name = \u0026#34;origin set\u0026#34; f.Age = i } } // ReflectUpdate 反射修改 f 值 func ReflectUpdate(f interface{}) { v := reflect.ValueOf(f) if v.Kind() != reflect.Ptr \u0026amp;\u0026amp; v.Elem().Type().Name() != \u0026#34;Foo\u0026#34; { panic(\u0026#34;not match type\u0026#34;) } ve := v.Elem() //ve.Field(0).SetString(\u0026#34;reflect modify\u0026#34;) //ve.Field(1).SetInt(100) ve.FieldByName(\u0026#34;Name\u0026#34;).SetString(\u0026#34;fieldByName modify\u0026#34;) ve.FieldByName(\u0026#34;Age\u0026#34;).SetInt(999) } 测试结果: 直接赋值: goos: darwin goarch: amd64 BenchmarkReflectUpdate BenchmarkReflectUpdate-12 1000000000\t0.291 ns/op field反射: goos: darwin goarch: amd64 BenchmarkReflectUpdate BenchmarkReflectUpdate-12 55756632\t18.5 ns/op fieldByName反射: goos: darwin goarch: amd64 BenchmarkReflectUpdate BenchmarkReflectUpdate-12 8810466\t123 ns/op 直接赋值~=63*Field反射~=422*FieldByName反射修改 5 反射应用 # 官方包：\nfmt系列\nfmt.Printf(\u0026#34;%T\u0026#34;,5) 对应的代码: switch verb { case \u0026#39;T\u0026#39;: p.fmt.fmtS(reflect.TypeOf(arg).String()) return case \u0026#39;p\u0026#39;: p.fmtPointer(reflect.ValueOf(arg), \u0026#39;p\u0026#39;) return } reflect.DeepEqual\n比较类型,类型不同返回false, 递归比较值 func TestDeepReflect(t *testing.T) { var a int32 = 1 var b rune = 1 fmt.Println(reflect.DeepEqual(a, b)) } 结果: === RUN TestDeepReflect true --- PASS: TestDeepReflect (0.00s) PASS json 对象序列化和反序列化\nfunc Marshal(v interface{})([]byte, error) //接口interface{}类型,返回字节切片 func Unmarshal(data []byte, v interface{}) error // 如果为字节切片, interface类型4、... 第三方包\nproto reflect xorm: go提供的关系对象模型操作库,运用反射 switch beanKind { case reflect.Struct: 下·下· fields, err := rows.Columns() if err != nil { // WARN: Alougth rows return true, but get fields failed return true, err } scanResults, err := session.row2Slice(rows, fields, bean) if err != nil { return false, err } // close it before covert data rows.Close() dataStruct := rValue(bean) _, err = session.slice2Bean(scanResults, fields, bean, \u0026amp;dataStruct, table) if err != nil { return true, err } return true, session.executeProcessors() "},{"id":3,"href":"/docs/java%E5%9F%BA%E7%A1%80/jvm/","title":"Jvm","section":"java基础","content":"TODO\n"},{"id":4,"href":"/docs/java%E5%9F%BA%E7%A1%80/lambda/","title":"Lambda","section":"java基础","content":" Optional # Optional用法:\n无法判断被调用传递过来的list 是否为空, 可以省略if null的判断条件\nList\u0026lt;String\u0026gt; carsFiltered = Optional.ofNullable(cars) .orElseGet(Collections::emptyList) .stream() .filter(Objects::nonNull) //filtering car object that are null .map(Car::getName) //now it\u0026#39;s a stream of Strings .filter(Objects::nonNull) //filtering null in Strings .filter(name -\u0026gt; name.startsWith(\u0026#34;M\u0026#34;)) .collect(Collectors.toList()); //back to List of Strings "},{"id":5,"href":"/docs/java%E5%9F%BA%E7%A1%80/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","title":"线程池","section":"java基础","content":"TODO\n"},{"id":6,"href":"/docs/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88/","title":"集合","section":"java基础","content":"TODO\n"},{"id":7,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhosue/sql-join/","title":"SQL Join","section":"clickhosue","content":"clickhouse\n常用操作\njoin # 所有的join 操作基本范式都是\n​\ttable1 join table2 on table.xxx=table2.xxx\n​\tjoin table3 on table1.xxx=table3.xxx\n​\tjoin table4 on table2.xxx=table4.xxx\n不允许先查询 再进行join,错误查询示例\nselect * from table_a where age=12 (inner) join table_b on table_a.id =table_b.id left joni table_c on table a.id=table_c.id where table_a.name=\u0026#39;xxxx\u0026#34; (innser)join操作 # ​\t内连接,去两个表on 交集\nselect * from table_a (inner) join table_b on table_a.id =table_b.id where table_a.name=\u0026#39;\u0026#39;xxxx\u0026#34; ​\nLeft join # 左边为空时,会导致不会查到任何数据\n左连接,取左表所有\nselect * from table_a left join table_b on table_a.id =table_b.id where table_a.name=\u0026#39;\u0026#39;xxxx\u0026#34; right join # 右表所有,加on条件左表\nselect * from table_a right join table_b on table_a.id =table_b.id where table_a.name=\u0026#39;\u0026#39;xxxx\u0026#34; full join\nself join\ncross join\nunion all /union distinct # 基本语法\nSELECT column1, column2 ... FROM table1, table2 [WHERE condition1] UNION / UNION ALL SELECT column1, column2 ... FROM table1, table2 [WHERE condition2] union distinct会对数据进行去重,(mysql中union 本身就具有去重逻辑) union all 直接将结果数据进行连接 "},{"id":8,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhosue/%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE/","title":"物化视图","section":"clickhosue","content":"物化视图相关功能\n"},{"id":9,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/clickhosue/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/","title":"运维相关","section":"clickhosue","content":" system.clusters表 # 作用: 查询系统的集群信息\nsystem.query_log # 系统日志:\nsystem.parts # 系统表:根据此表可以查询表的分区信息,以及占用的空间大小\nSELECT TABLE, -- 表名 DATABASE, -- 数据库名 max(partition) AS part, -- 最大分区 formatReadableSize(sum(bytes_on_disk)) AS SIZE, -- 磁盘容量 sum(bytes_on_disk) AS size_bytes -- 磁盘容量 FROM system.parts_all GROUP BY TABLE, DATABASE ORDER BY size_bytes DESC system.disks # 查询磁盘使用率\nSELECT sum(total_space -free_space)/sum(total_space) AS USAGE, -- 使用率 count(*) , -- 节点数量 formatReadableSize(sum(total_space -free_space)) AS foramat_usage, -- 使用空间大小 formatReadableSize(sum(total_space)) AS format_total --总空间大小 FROM clusterAllReplicas(\u0026#39;clickhouse_pcg_video_data_science_2_replica\u0026#39;,system,disks); 数据导出命令 # mysql -h{host} -u{user}-P{port} -D{db} --password=\u0026#39;{passwod}\u0026#39; -e \u0026#34;sql\u0026#34; \u0026gt; file.csv "},{"id":10,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/","title":"数据分片","section":"elasticsearch","content":"TODO\n"},{"id":11,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch/%E8%B0%83%E4%BC%98/","title":"调优","section":"elasticsearch","content":"TODO\n"},{"id":12,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mvcc%E6%A8%A1%E5%9E%8B/","title":"Mvcc模型","section":"mysql","content":"TODO\n"},{"id":13,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/%E4%BA%8B%E5%8A%A1/","title":"事务","section":"mysql","content":"TODO\n"},{"id":14,"href":"/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/%E6%9E%B6%E6%9E%84/","title":"架构","section":"redis","content":" redis 架构 # 持久化方式 # rdb: fork进程\naof: 一个线程,\n一致性hash: # 一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中 K 是关键字的数量，n 是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。\n多级缓存: # 缓存更新、缓存一致性问题\nkey\u0026mdash;key\u0026mdash;\u0026gt;value形式 还是key-value形式\n"},{"id":15,"href":"/docs/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E4%BF%A1%E6%9E%B6%E6%9E%84/","title":"微信架构","section":"架构","content":"微信架构\n"},{"id":16,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","section":"算法","content":"TODO\n"},{"id":17,"href":"/docs/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","title":"回溯","section":"算法","content":"TODO\n"},{"id":18,"href":"/docs/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","title":"贪心算法","section":"算法","content":"贪心算法定义\n"},{"id":19,"href":"/menu/","title":"Index","section":"Introduction","content":" headless: true # "}]